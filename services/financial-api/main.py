# services/finance-api/main.py
"""
IHEP Financial Generation Engine

This service manages the economic model that transforms health engagement into
monetary value for patients while funding research and platform sustainability.

Key features:
- Engagement-to-value conversion using game theory
- Research funding allocation with Nash equilibrium optimization
- Transparent value distribution to patients
- Real-time economic impact tracking
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import jwt
from functools import wraps
import logging
from google.cloud import logging as cloud_logging
from google.cloud import bigquery
from datetime import datetime, timedelta
import hashlib
import json
from decimal import Decimal
import redis

app = Flask(__name__)
CORS(app, origins=os.getenv('ALLOWED_ORIGINS', '*').split(','))

# Initialize logging
logging_client = cloud_logging.Client()
logging_client.setup_logging()
logger = logging.getLogger(__name__)

# Redis for caching
redis_client = redis.Redis(
    host=os.getenv('REDIS_HOST', 'localhost'),
    port=int(os.getenv('REDIS_PORT', 6379)),
    db=2,
    decode_responses=True
)

# BigQuery for analytics
bq_client = bigquery.Client()
PROJECT_ID = os.getenv('PROJECT_ID')
JWT_SECRET = os.getenv('JWT_SECRET')

def require_auth(f):
    """Authentication decorator"""
    @wraps(f)
    def wrapped(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({'error': 'No authorization header'}), 401
        
        try:
            token = auth_header.split(' ')[1]
            payload = jwt.decode(token, JWT_SECRET, algorithms=['HS256'])
            request.user_id = payload['user_id']
            return f(*args, **kwargs)
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
    
    return wrapped

class EconomicModel:
    """
    Economic model for health engagement value generation.
    
    The model uses a multi-factor approach where engagement value is calculated as:
    V(t) = Σ(w_i * E_i(t) * Q_i(t))
    
    Where:
    - V(t) = Total value generated at time t
    - w_i = Weight factor for engagement type i
    - E_i(t) = Engagement level for type i
    - Q_i(t) = Quality multiplier for type i
    
    The economic model implements a cooperative game theory framework where
    the total value pool is distributed among stakeholders according to
    their contribution using the Shapley value:
    
    φ_i(v) = (1/n!) Σ[π∈Π(N)] [v(S_π(i) ∪ {i}) - v(S_π(i))]
    
    Where:
    - φ_i(v) = Shapley value for player i
    - N = set of all players
    - Π(N) = set of all permutations of N
    - S_π(i) = set of players preceding i in permutation π
    - v(S) = value function for coalition S
    """
    
    def __init__(self):
        # Engagement type weights (empirically derived)
        self.engagement_weights = {
            'appointment_attendance': 0.25,
            'medication_adherence': 0.30,
            'health_data_sharing': 0.20,
            'community_participation': 0.15,
            'wellness_activities': 0.10
        }
        
        # Quality multipliers based on consistency and accuracy
        self.quality_multipliers = {
            'high': 1.5,    # 90%+ consistency
            'medium': 1.2,  # 70-89% consistency
            'low': 0.8,     # 50-69% consistency
            'poor': 0.5     # <50% consistency
        }
        
        # Value distribution percentages
        self.value_distribution = {
            'patient_rewards': 0.40,      # Direct to patients
            'research_funding': 0.35,     # Research initiatives
            'platform_sustainability': 0.15,  # Platform operations
            'community_development': 0.10     # Community programs
        }

    def calculate_engagement_value(self, user_id, engagement_data):
        """
        Calculate value generated by user engagement.
        
        Mathematical model:
        V_user = Σ(w_i * E_i * Q_i * T_i)
        
        Where T_i is the time decay factor to prevent gaming:
        T_i(t) = e^(-λ(t-t_0)) where λ is decay rate
        """
        total_value = 0.0
        
        current_time = datetime.utcnow()
        
        for engagement_type, data in engagement_data.items():
            if engagement_type in self.engagement_weights:
                weight = self.engagement_weights[engagement_type]
                engagement_level = data.get('level', 0)
                quality = data.get('quality', 'medium')
                timestamp = data.get('timestamp')
                
                # Calculate time decay factor (7-day half-life)
                if timestamp:
                    time_diff = (current_time - timestamp).total_seconds() / 3600  # hours
                    decay_factor = 2 ** (-time_diff / 168)  # 168 hours = 1 week
                else:
                    decay_factor = 1.0
                
                quality_multiplier = self.quality_multipliers.get(quality, 1.0)
                
                # Base value calculation
                base_value = weight * engagement_level * quality_multiplier * decay_factor
                total_value += base_value
                
                logger.info(f"Engagement value for {user_id}: {engagement_type} = {base_value}")
        
        return total_value

    def calculate_shapley_value(self, user_contributions, total_pool):
        """
        Calculate fair value distribution using Shapley value.
        
        This implements the core of cooperative game theory to ensure
        fair distribution of rewards based on marginal contributions.
        
        For computational efficiency, we use an approximation:
        φ_i ≈ (marginal_contribution_i / total_marginal_contributions) * total_pool
        """
        total_marginal_contribution = sum(user_contributions.values())
        
        if total_marginal_contribution == 0:
            return {}
        
        shapley_values = {}
        for user_id, contribution in user_contributions.items():
            shapley_values[user_id] = (contribution / total_marginal_contribution) * total_pool
        
        return shapley_values

    def allocate_value_pool(self, total_value):
        """
        Allocate total value to different stakeholder groups.
        
        Returns dictionary with allocation amounts for each group.
        """
        allocations = {}
        for group, percentage in self.value_distribution.items():
            allocations[group] = total_value * percentage
        
        return allocations

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({
        'status': 'healthy',
        'service': 'finance-api',
        'timestamp': datetime.utcnow().isoformat()
    }), 200

@app.route('/value/calculate', methods=['POST'])
@require_auth
def calculate_user_value():
    """
    Calculate value generated by user engagement and update their balance.
    
    This endpoint processes engagement data and calculates the monetary
    value generated, then updates the user's account balance accordingly.
    """
    try:
        data = request.get_json()
        engagement_data = data.get('engagement_data', {})
        
        # Initialize economic model
        model = EconomicModel()
        
        # Calculate engagement value
        user_value = model.calculate_engagement_value(request.user_id, engagement_data)
        
        # Get user's current balance
        balance_key = f"balance:{request.user_id}"
        current_balance = float(redis_client.get(balance_key) or 0.0)
        
        # Update balance
        new_balance = current_balance + user_value
        redis_client.setex(balance_key, 86400, str(new_balance))  # 24-hour TTL
        
        # Log transaction
        transaction = {
            'user_id': request.user_id,
            'timestamp': datetime.utcnow().isoformat(),
            'value_added': user_value,
            'new_balance': new_balance,
            'engagement_details': engagement_data
        }
        
        # Store in BigQuery for analytics
        table_id = f"{PROJECT_ID}.ihep_finance.user_value_transactions"
        bq_client.insert_rows_json(table_id, [transaction])
        
        logger.info(f"Value calculated for user {request.user_id}: {user_value}")
        
        return jsonify({
            'value_added': round(user_value, 4),
            'new_balance': round(new_balance, 4),
            'message': 'Value successfully calculated and added to your account'
        }), 200
        
    except Exception as e:
        logger.error(f"Error calculating user value: {str(e)}")
        return jsonify({'error': 'Failed to calculate value'}), 500

@app.route('/balance', methods=['GET'])
@require_auth
def get_user_balance():
    """Get user's current value balance"""
    try:
        balance_key = f"balance:{request.user_id}"
        balance = float(redis_client.get(balance_key) or 0.0)
        
        return jsonify({
            'balance': round(balance, 4),
            'currency': 'USD',
            'last_updated': redis_client.ttl(balance_key)
        }), 200
        
    except Exception as e:
        logger.error(f"Error retrieving balance: {str(e)}")
        return jsonify({'error': 'Failed to retrieve balance'}), 500

@app.route('/value/pool', methods=['GET'])
def get_value_pool_status():
    """
    Get current status of the community value pool.
    
    This shows how the collective engagement is generating value
    and how it's being allocated across different initiatives.
    """
    try:
        # Get total value in pool (last 24 hours)
        pool_query = f"""
        SELECT 
            SUM(value_added) as total_value,
            COUNT(DISTINCT user_id) as active_users,
            AVG(value_added) as avg_per_user
        FROM `{PROJECT_ID}.ihep_finance.user_value_transactions`
        WHERE timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 24 HOUR)
        """
        
        query_job = bq_client.query(pool_query)
        results = list(query_job.result())
        
        if results:
            total_value = float(results[0].total_value or 0)
            active_users = results[0].active_users or 0
            avg_per_user = float(results[0].avg_per_user or 0)
        else:
            total_value = 0
            active_users = 0
            avg_per_user = 0
        
        # Initialize economic model for allocation
        model = EconomicModel()
        allocations = model.allocate_value_pool(total_value)
        
        return jsonify({
            'total_value': round(total_value, 4),
            'active_users': active_users,
            'avg_value_per_user': round(avg_per_user, 4),
            'allocations': {
                group: round(amount, 4) 
                for group, amount in allocations.items()
            },
            'timestamp': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Error retrieving pool status: {str(e)}")
        return jsonify({'error': 'Failed to retrieve pool status'}), 500

@app.route('/rewards/eligible', methods=['GET'])
@require_auth
def get_eligible_rewards():
    """Get rewards that user is eligible for based on their balance"""
    try:
        balance_key = f"balance:{request.user_id}"
        balance = float(redis_client.get(balance_key) or 0.0)
        
        # Sample rewards catalog
        rewards = [
            {
                'id': 'wellness_kit',
                'name': 'Wellness Starter Kit',
                'description': 'Complete wellness package with supplements and tracking tools',
                'value': 25.00,
                'eligible': balance >= 25.00
            },
            {
                'id': 'fitness_tracker',
                'name': 'Fitness Tracker Device',
                'description': 'Advanced fitness tracker with health monitoring',
                'value': 75.00,
                'eligible': balance >= 75.00
            },
            {
                'id': 'telehealth_session',
                'name': 'Premium Telehealth Session',
                'description': 'Extended consultation with specialist',
                'value': 50.00,
                'eligible': balance >= 50.00
            },
            {
                'id': 'community_donation',
                'name': 'Community Health Fund Donation',
                'description': 'Donate your value to support community health initiatives',
                'value': balance,
                'eligible': balance > 0
            }
        ]
        
        return jsonify({
            'balance': round(balance, 4),
            'rewards': rewards,
            'timestamp': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Error retrieving rewards: {str(e)}")
        return jsonify({'error': 'Failed to retrieve rewards'}), 500

@app.route('/rewards/redeem', methods=['POST'])
@require_auth
def redeem_reward():
    """Redeem user's value balance for rewards"""
    try:
        data = request.get_json()
        reward_id = data.get('reward_id')
        
        if not reward_id:
            return jsonify({'error': 'Reward ID required'}), 400
        
        # Get user balance
        balance_key = f"balance:{request.user_id}"
        current_balance = float(redis_client.get(balance_key) or 0.0)
        
        # Get reward value
        reward_values = {
            'wellness_kit': 25.00,
            'fitness_tracker': 75.00,
            'telehealth_session': 50.00,
            'community_donation': current_balance
        }
        
        reward_value = reward_values.get(reward_id)
        if not reward_value:
            return jsonify({'error': 'Invalid reward ID'}), 400
        
        if current_balance < reward_value:
            return jsonify({'error': 'Insufficient balance'}), 400
        
        # Deduct value from balance
        new_balance = current_balance - reward_value
        redis_client.setex(balance_key, 86400, str(new_balance))
        
        # Log reward redemption
        redemption = {
            'user_id': request.user_id,
            'reward_id': reward_id,
            'value_redeemed': reward_value,
            'timestamp': datetime.utcnow().isoformat(),
            'new_balance': new_balance
        }
        
        table_id = f"{PROJECT_ID}.ihep_finance.reward_redemptions"
        bq_client.insert_rows_json(table_id, [redemption])
        
        logger.info(f"Reward redeemed by user {request.user_id}: {reward_id}")
        
        return jsonify({
            'message': 'Reward successfully redeemed',
            'reward_id': reward_id,
            'value_redeemed': round(reward_value, 4),
            'new_balance': round(new_balance, 4)
        }), 200
        
    except Exception as e:
        logger.error(f"Error redeeming reward: {str(e)}")
        return jsonify({'error': 'Failed to redeem reward'}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.getenv('PORT', 8080)))
